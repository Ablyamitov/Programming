#include<iostream>

#include<vector>

#include <fstream>


using namespace std;

std::ostream& operator << (std::ostream& out, const vector<int>& mass) {
	out << mass.size() << "\t" << "| ";
	for (int i = 0; i < mass.size(); i++) {
		out << &mass[i] << " ";
	}
	out << endl;
	return out;
}

//ЧАСТЬ 3
/*std::ostream& operator << (std::ostream& out, const vector<int> mass) {
	out << mass.size() << "\t" << "| ";
	for (int i = 0; i < mass.size(); i++) {
		out << &mass[i] << " ";						
	}
	out << endl;
	return out;
}*/

int main() {
	vector<int> mass;
	ofstream file;
	file.open("data.txt");
	char symb = 'x';
	size_t vector_size = 63;
	for (int i = 0; i < vector_size;i++) {
		mass.push_back(symb);
		file << mass;
	}
	for (int i = 0;i < vector_size;i++) {
		mass.pop_back();
		file << mass;
	}
	file.close();

}
//Сравнив адреса элементов вектора с одинаковыми индексами, сделал вывод, что
/* Вопрос 1. Адреса элемента вектора всегда отличаются, т.к. с помощью оператора << вектор копируется,
а так как элементы идут последовательно,то адреса следующих элементов увеличиваются на размер того, сколько байт занимает int)
Нет, потому что вектор будет перемещён в новую память.

Вопрос 2. Из-за того, что вектор переместиться в новую память, значение нулевой ячейки вектора не измениться. 


Вопрос 3. (Аналогично Вопросу 1) Адреса элемента вектора всегда отличаются, т.к. с помощью оператора << вектор копируется,
а так как элементы идут последовательно,то адреса следующих элементов увеличиваются на размер того, сколько байт занимает int)
Нет, потому что вектор будет перемещён в новую память..


Вопрос 4. Изменения присутствуют. Если использовать pop_back() для вектора, который мы передали по значению, уменьшится сама длина вектора, а объём
используемой памяти останется прежним, следовательно, в памяти не выделится новое место и первый элемент вектора останется с старым адресом*/